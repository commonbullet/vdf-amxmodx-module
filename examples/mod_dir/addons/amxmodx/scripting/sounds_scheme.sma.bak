/* Plugin generated by AMXX-Studio */

/*
 *	------------------------------------------------------------------
 *	  This is part of Vdf module examples, designed only to test and 
 *	  demonstrate this module functionality.
 *	  For more information check this topic:
 *	  http://forums.alliedmods.net/showthread.php?t=51662
 *	------------------------------------------------------------------
 */
 
/*
 *	WARNING:
 *	This example should work in CS only.
 *	
 *	DESCRIPTION:
 *	Uses open tree forward to store data for playing sounds on some events.
 *	The server may choose different schemes from vdf files.
 *
 *	COMMANDS:
 *	open_scheme_cmd - opens scheme file
 *
 *	CVARS:
 *	default_sound_scheme - default scheme
 */

#include <amxmodx>
#include <amxmisc>
#include <vdf>

#define PLUGIN "sounds scheme"
#define VERSION "1.04"
#define AUTHOR "commonbullet"

#define SOUNDS_NUM 3
#define TXT_UNASSIGNED "<unassigned>"
#define TXT_SCHEME_CHANGED "Sound scheme changed, using %s."
#define TXT_ERROR_OPEN "Could not open sound scheme %s."

#define SNDID_NEW_ROUND 0
#define SNDID_END_ROUND 1
#define SNDID_CONNECT 2

new VdfTree:g_SoundScheme
new g_SchemeName[32]
new VdfNode:g_Sounds[SOUNDS_NUM]
new g_cvarDefaultScheme

new const g_soundTags[SOUNDS_NUM][] = 
{
	"new_round",
	"end_round",
	"client_connect"
}

public plugin_init() 
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	g_cvarDefaultScheme = register_cvar("default_sound_scheme", "default_sound_scheme.vdf")
	
	register_concmd("open_scheme", "open_scheme_cmd")
	register_event("HLTV", "new_round", "a", "1=0", "2=0")
	register_event("SendAudio", "end_round", "a", "2&%!MRAD_terwin", "2&%!MRAD_ctwin", "2&%!MRAD_rounddraw")
}

public plugin_cfg()
{
	new schfile[96]
	new filename[48]
	
	get_pcvar_string(g_cvarDefaultScheme, filename, 47)
	get_scheme_file(filename, schfile, 96)
	open_scheme(schfile)
}

get_scheme_file(const filename[], schfile[], maxlen)
{
	new dir[72]
	
	get_configsdir(dir, 71)	
	format(schfile, maxlen - 1, "%s/sound_schemes/%s", dir, filename)	
}

public open_scheme_cmd(id)
{
	new filename[65]
	new schfile[96]
	
	read_args(filename, 64)
	get_scheme_file(filename, schfile, 96)
	
	if(open_scheme(schfile))
		console_print(id, TXT_SCHEME_CHANGED, g_SchemeName)
	else
		console_print(id, TXT_ERROR_OPEN, schfile)
	
	return PLUGIN_HANDLED
}
	

public bool:open_scheme(const filename[])
{
	new VdfTree:tree
	
	if((tree = vdf_open(filename, "parse_tree"))) {
		g_SoundScheme = tree
		return true
	}
	return false		
}

/*
 *	Here's the proper way to catch nodes added event
 *	registered by vdf_open_tree native
 */
public parse_tree(const filename[], VdfTree:tree, VdfNode:node, level)
{
	static key[16]
	
	if(level == 0) {
		for(new i = 0; i < SOUNDS_NUM; i++)
			g_Sounds[i] = VDF_NULL_NODE
			
		vdf_get_node_key(node, g_SchemeName, 31)
		return 0
	}
	else {
		vdf_get_node_key(node, key, 15)
		for(new i = 0; i < SOUNDS_NUM; i++) {
			if(equal(key, g_soundTags[i])) {
				g_Sounds[i] = node
				return 0
			}
		}
	}
	
	return VDF_OPEN_CONTINUE
	
}

play_sound(sndid)
{
	if(g_SoundScheme && g_Sounds[sndid]) {
		new snd[32]
		
		vdf_get_node_value(g_Sounds[sndid], snd, 31)
		client_cmd(0, "spk %s", snd)
	}	
}

public client_connect(id)
{
	if(g_SoundScheme) {
		play_sound(SNDID_CONNECT)
	}
	
	return PLUGIN_CONTINUE
}

public end_round()
{
	if(g_SoundScheme)
		play_sound(SNDID_END_ROUND)
}

public new_round()
{
	if(g_SoundScheme)
		play_sound(SNDID_NEW_ROUND)
}
