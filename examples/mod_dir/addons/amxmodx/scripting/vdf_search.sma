/* Plugin generated by AMXX-Studio */

/*
 *	------------------------------------------------------------------
 *	  This is part of Vdf module examples, designed only to test and 
 *	  demonstrate this module functionality.
 *	  For more information check this topic:
 *	  http://forums.alliedmods.net/showthread.php?t=51662
 *	------------------------------------------------------------------
 */


/*
 *	Description:
 *	-------------
 *	This examples performs a search in a vdf tree.
 *	As default settings it ignores case and search at any node level (-1).
 *
 *	Commands:
 *	
 *	open_tree	[filename]	-	opens a vdf tree
 *	search_key	[key]		-	searches for the specified key
 *	search_value	[value]		-	searches for the specified value
 */

#include <amxmodx>
#include <amxmisc>
#include <vdf>

#define PLUGIN "vdf search"
#define VERSION "1.04"
#define AUTHOR "commonbullet"

#define LOG_FILE_NOT_FOUND "Error: %s file not found."
#define LOG_OPEN_FAIL "Error failed trying to open vdf tree file."
#define LOG_FILE_OPENED "File %s successfully opened."
#define LOG_NO_VDF_FILE "No vdf file has been opened."
#define LOG_NODE_NOT_FOUND "No matches for %s."

new VdfTree:g_VdfTree
new VdfSearch:g_VdfSearch

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)

	register_concmd("search_key", "search_key")
	register_concmd("search_value", "search_value")
	register_concmd("open_tree", "open_tree")
	register_concmd("traverse_tree", "traverse_tree")
}

public open_tree(id)
{
	new args[62]
	
	read_args(args, 61)	
	
	// you don't need to file check before trying to
	// calling vdf_open, but since there are other reasons
	// vdf_open may result in 0, it's cool to provide the
	// user a precise informartion.
	if(!file_exists(args)) {
		console_print(id, LOG_FILE_NOT_FOUND, args)
		return PLUGIN_HANDLED
	}
	
	if(g_VdfTree) {
		vdf_remove_tree(g_VdfTree)
		g_VdfTree = VDF_NULL_TREE
	}
	
	if(!(g_VdfTree = vdf_open(args)))
		console_print(id, LOG_OPEN_FAIL)
	else
		console_print(id, LOG_FILE_OPENED, args)
		
	return PLUGIN_HANDLED	
	
}


public traverse_tree(id)
{
	if(!g_VdfTree) {
		console_print(id, LOG_NO_VDF_FILE)
		return
	}
	
	new VdfNode:node
	new depth
	new tabs [256] = {'^t', ...}
	new buffer[512]
	new key [256]
	new value[256]
	
	for(node = vdf_get_root_node(g_VdfTree); node != VdfNode:0; node = vdf_next_in_traverse(node, depth))
	{
		tabs[depth] = 0
		vdf_get_node_key(node, key, 255)
		vdf_get_node_value(node, value, 255)
		formatex(buffer, 511, "%s %s  %s", tabs,key, value)
		server_print(buffer)
		tabs[depth] = '^t'
	}
	
}

public search_tree(id, const str[], schkey)
{
	if(!g_VdfTree) {
		console_print(id, LOG_NO_VDF_FILE)
		return
	}
	
	if(!g_VdfSearch)
		g_VdfSearch = vdf_create_search()
		
	new schtype
	new counter
	new key[32]
	new value[32]
	new VdfNode:node
	new level
	
	schtype = (schkey) ? VDF_MATCH_KEY : VDF_MATCH_VALUE
	
	if(g_VdfSearch)
		vdf_set_search(g_VdfSearch, g_VdfTree, str, schtype, -1, 1)
	
	while((node = vdf_find_next_match(g_VdfSearch, node))) {
		level = vdf_get_node_level(node)
		vdf_get_node_key(node, key, 31)
		vdf_get_node_value(node, value, 31)

		console_print(id, "Found node: {^"%s^", ^"%s^"} at level %d.", key, value, level)
		counter++
	}
	
	// It's not required to close a search if you plan to
	// search for another value - vdf_set_search should reset the search.
	// But it's a good idea that whenever you close it, you set it to 0 if it's global
	// This prevents from annoying crashes if you forget that you removed it
	// and try to use it again.
	vdf_close_search(g_VdfSearch)
	g_VdfSearch = VDF_NULL_SEARCH
	
	
	if(!counter)
		console_print(id, LOG_NODE_NOT_FOUND, str)

}

public search_key(id)
{
	new args[62]
	read_args(args, 61)
	trim(args)
	search_tree(id, args, 1)
	return PLUGIN_HANDLED
}

public search_value(id)
{
	new args[62]
	read_args(args, 61)
	trim(args)
	search_tree(id, args, 0)
	return PLUGIN_HANDLED
}
	
