/* Plugin generated by AMXX-Studio */

/*
 *	------------------------------------------------------------------
 *	  This is part of Vdf module examples, designed only to test and 
 *	  demonstrate this module functionality.
 *	  For more information check this topic:
 *	  http://forums.alliedmods.net/showthread.php?t=51662
 *	------------------------------------------------------------------
 */

/*
 *	This example represents a vdf file in server or client console, by
 *	using event parsing model.
 *
 *	Command:
 *
 *	parse_file [filename]	- opens a file to be parsed. If no file is specified,
 *				  a crap vdf file is created to be used as an example.
 *
 */


 
 
#include <amxmodx>
#include <vdf>

#define PLUGIN "vdf parser"
#define VERSION "1.05"
#define AUTHOR "commonbullet"

#define MAX_TABS 8


new const tab[MAX_TABS] = {'^t', ...}

new const g_Fmt_Started[] = "^n#Parse started (%s)"
new const g_Fmt_Finished[] = "#End of parse (%s)"
new const g_Fmt_FileNotFound[] =  "Couldn't open vdf file: %s"

new g_LastLevel = 0
new g_Id

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	register_concmd("parse_file", "parse_file")
}

public parse_file(id)
{
	new filename[64]
	
	read_args(filename, 63)
	
	// if no file have been specified, create a tree
	if(!strlen(filename)) {
		
		new VdfTree:tree;
		new VdfNode:node;
		
		format(filename, 63, "vdf_parser_test.vdf")
		
		tree = vdf_create_tree(filename)
		
		node = vdf_get_root_node(tree)
		vdf_set_node_key(node , "test_tree")
		
		node = vdf_append_child_node(tree, node, "fruits")
		vdf_append_child_node(tree, node, "banana", "1")
		vdf_append_child_node(tree, node, "apple", "2")
		vdf_append_child_node(tree, node, "watermelon", "3")
		
		node = vdf_append_node(tree, node, "cars")
		vdf_append_child_node(tree, node, "mercedes bens", "1")
		vdf_append_child_node(tree, node, "ferrari", "2")
		
		vdf_save(tree)
		vdf_remove_tree(tree)
	}
	
	if(!file_exists(filename)) {
		console_print(id, g_Fmt_FileNotFound , filename)
		return PLUGIN_HANDLED
	}
	g_Id = id

	// start and end events are optional
	vdf_parse(filename, "parse_keypairs", "parse_start", "parse_end")
	
	return PLUGIN_HANDLED
}

public parse_start(const filename[])
{
	console_print(g_Id, g_Fmt_Started, filename)
}

/*
 * 	key pairs forward syntax:
 *	(const filename[], const key[], const value[], level)
 *	"level" is the depth of a key pair in a tree.
 */
public parse_keypairs(const filename[], const key[], const value[], level)
{
	static output[64]
	new len
	new tabnum
	
	tabnum = level < MAX_TABS ? level : MAX_TABS - 1
	len = format(output, tabnum, "%s", tab)
	
	if(level != g_LastLevel) {
		len +=  (level > g_LastLevel) ? format(output[len - 1], 63 - len, "{^n") - 1 :
			format(output[len], 63 - len, "}^n")
		len += format(output[len], tabnum, "%s", tab)
	}
	
	len += format(output[len], 63 - len, "^"%s^"", key)
	if(value[0])
		format(output[len], 63 - len, " ^"%s^"", value)
		
	g_LastLevel = level
	
	console_print(g_Id, output)

	return VDFPARSER_CONTINUE
}

public parse_end(const filename[])
{
	static close[12]
	new len
	
	while(g_LastLevel)
	{	
		len = format(close, g_LastLevel - 1, tab)
		format(close[len], 12 - len, "}")
		console_print(g_Id, close)
		g_LastLevel--
	}		
	
	console_print(g_Id, g_Fmt_Finished, filename)
}


